{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/","matchPath":"/*","result":{"data":{"deck":{"id":"94bb3911-39bb-5b62-992b-af73127caa8b","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = vsDark;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Wyra\\u017Cenia lambda\"), mdx(\"p\", null, \"O funkcjach bez nazwy\"), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"file=\\\"example1.cpp\\\" subtitle=\\\"Załóżmy że chcemy posortować tablicę napisów\\\"\",\n    \"file\": \"\\\"example1.cpp\\\"\",\n    \"subtitle\": \"\\\"Załóżmy\",\n    \"że\": true,\n    \"chcemy\": true,\n    \"posortować\": true,\n    \"tablicę\": true,\n    \"napisów\\\"\": true\n  }), \"#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nint main() {\\n    vector<string> napisy = {\\n        \\\"Roses are red,\\\",\\n        \\\"Henry Cavill is dreamy\\\",\\n        \\\"To complete the rhyme\\\",\\n        \\\"you must mispronounce meme\\\",\\n    };\\n\\n    sort(napisy.begin(), napisy.end());\\n\\n    for(auto& napis : napisy) {\\n        cout << napis << endl;\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"file=\\\"example2.cpp\\\" subtitle=\\\"...ale według długości\\\"\",\n    \"file\": \"\\\"example2.cpp\\\"\",\n    \"subtitle\": \"\\\"...ale\",\n    \"według\": true,\n    \"długości\\\"\": true\n  }), \"#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nbool porownaj(string const& L, string const& R) {\\n    return L.size() < R.size();\\n}\\n\\nint main() {\\n    vector<string> napisy = {\\n        \\\"Roses are red,\\\",\\n        \\\"Henry Cavill is dreamy\\\",\\n        \\\"To complete the rhyme\\\",\\n        \\\"you must mispronounce meme\\\",\\n    };\\n\\n    sort(napisy.begin(), napisy.end(), porownaj);\\n\\n    for(auto& napis : napisy) {\\n        cout << napis << endl;\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"7[6:13] subtitle=\\\"Nazwa tej funkcji właściwie nic nie wnosi...\\\"\",\n    \"7[6:13]\": true,\n    \"subtitle\": \"\\\"Nazwa\",\n    \"tej\": true,\n    \"funkcji\": true,\n    \"właściwie\": true,\n    \"nic\": true,\n    \"nie\": true,\n    \"wnosi...\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"19\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"19 subtitle=\\\"Może moglibyśmy stworzyć funkcję tam, gdzie jej używamy?\\\"\",\n    \"subtitle\": \"\\\"Może\",\n    \"moglibyśmy\": true,\n    \"stworzyć\": true,\n    \"funkcję\": true,\n    \"tam,\": true,\n    \"gdzie\": true,\n    \"jej\": true,\n    \"używamy?\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"file=\\\"example3.cpp\\\" subtitle=\\\"Moglibyśmy — za pomocą wyrażenia lambda\\\"\",\n    \"file\": \"\\\"example3.cpp\\\"\",\n    \"subtitle\": \"\\\"Moglibyśmy\",\n    \"—\": true,\n    \"za\": true,\n    \"pomocą\": true,\n    \"wyrażenia\": true,\n    \"lambda\\\"\": true\n  }), \"#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nint main() {\\n    vector<string> napisy = {\\n        \\\"Roses are red,\\\",\\n        \\\"Henry Cavill is dreamy\\\",\\n        \\\"To complete the rhyme\\\",\\n        \\\"you must mispronounce meme\\\",\\n    };\\n\\n    sort(napisy.begin(), napisy.end(),\\n    [](string const& L, string const& R) {\\n        return L.size() < R.size();\\n    });\\n\\n    for(auto& napis : napisy) {\\n        cout << napis << endl;\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"16[5:6] subtitle=\\\"Funkcję anonimową rozpoczyna para nawiasów kwadratowych\\\"\",\n    \"16[5:6]\": true,\n    \"subtitle\": \"\\\"Funkcję\",\n    \"anonimową\": true,\n    \"rozpoczyna\": true,\n    \"para\": true,\n    \"nawiasów\": true,\n    \"kwadratowych\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"16[7:40] subtitle=\\\"Później mamy normalną listę argumentów\\\"\",\n    \"16[7:40]\": true,\n    \"subtitle\": \"\\\"Później\",\n    \"mamy\": true,\n    \"normalną\": true,\n    \"listę\": true,\n    \"argumentów\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"16[42],17,18[5] subtitle=\\\"i w klamerkach, zawartość funkcji\\\"\",\n    \"16[42],17,18[5]\": true,\n    \"subtitle\": \"\\\"i\",\n    \"w\": true,\n    \"klamerkach,\": true,\n    \"zawartość\": true,\n    \"funkcji\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"16[42:48] file=\\\"example-with-rettype.cpp\\\" subtitle=\\\"Jeżeli chcemy, możemy dodać typ zwracanej wartości\\\"\",\n    \"16[42:48]\": true,\n    \"file\": \"\\\"example-with-rettype.cpp\\\"\",\n    \"subtitle\": \"\\\"Jeżeli\",\n    \"chcemy,\": true,\n    \"możemy\": true,\n    \"dodać\": true,\n    \"typ\": true,\n    \"zwracanej\": true,\n    \"wartości\\\"\": true\n  }), \"#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nint main() {\\n    vector<string> napisy = {\\n        \\\"Roses are red,\\\",\\n        \\\"Henry Cavill is dreamy\\\",\\n        \\\"To complete the rhyme\\\",\\n        \\\"you must mispronounce meme\\\",\\n    };\\n\\n    sort(napisy.begin(), napisy.end(),\\n    [](string const& L, string const& R) -> bool {\\n        return L.size() < R.size();\\n    });\\n\\n    for(auto& napis : napisy) {\\n        cout << napis << endl;\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"file=\\\"inferred-types.cpp\\\" subtitle=\\\"Lub na odwrót, kazać kompilatorowi dobrać typy samemu\\\"\",\n    \"file\": \"\\\"inferred-types.cpp\\\"\",\n    \"subtitle\": \"\\\"Lub\",\n    \"na\": true,\n    \"odwrót,\": true,\n    \"kazać\": true,\n    \"kompilatorowi\": true,\n    \"dobrać\": true,\n    \"typy\": true,\n    \"samemu\\\"\": true\n  }), \"#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nint main() {\\n    vector<string> napisy = {\\n        \\\"Roses are red,\\\",\\n        \\\"Henry Cavill is dreamy\\\",\\n        \\\"To complete the rhyme\\\",\\n        \\\"you must mispronounce meme\\\",\\n    };\\n\\n    sort(napisy.begin(), napisy.end(),\\n    [](auto L, auto R) {\\n        return L.size() < R.size();\\n    });\\n\\n    for(auto& napis : napisy) {\\n        cout << napis << endl;\\n    }\\n}\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"file=\\\"counting-example.cpp\\\" subtitle=\\\"Biblioteka standardowa ma wiele tego typu przydatnych funkcji\\\"\",\n    \"file\": \"\\\"counting-example.cpp\\\"\",\n    \"subtitle\": \"\\\"Biblioteka\",\n    \"standardowa\": true,\n    \"ma\": true,\n    \"wiele\": true,\n    \"tego\": true,\n    \"typu\": true,\n    \"przydatnych\": true,\n    \"funkcji\\\"\": true\n  }), \"#include <algorithm>\\n#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nint policz_spacje(string napis) {\\n    return count_if(napis.begin(), napis.end(),\\n    [](char c) {\\n        return c == ' ';\\n    });\\n}\\n\\nint main() {\\n    cout << policz_spacje(\\\"The quick brown fox jumps over the lazy dog\\\") << '\\\\n';\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"7[12:19],8:10 subtitle=\\\"count_if wywoła naszą funkcję na każdym znaku stringa i policzy ile razy zwóci true\\\"\",\n    \"7[12:19],8:10\": true,\n    \"subtitle\": \"\\\"count_if\",\n    \"wywoła\": true,\n    \"naszą\": true,\n    \"funkcję\": true,\n    \"na\": true,\n    \"każdym\": true,\n    \"znaku\": true,\n    \"stringa\": true,\n    \"i\": true,\n    \"policzy\": true,\n    \"ile\": true,\n    \"razy\": true,\n    \"zwóci\": true,\n    \"true\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"file=\\\"counting2.cpp\\\" subtitle=\\\"ale czasami chcielibyśmy wykorzystać zmienne z poza naszej anonimowej funkcji\\\"\",\n    \"file\": \"\\\"counting2.cpp\\\"\",\n    \"subtitle\": \"\\\"ale\",\n    \"czasami\": true,\n    \"chcielibyśmy\": true,\n    \"wykorzystać\": true,\n    \"zmienne\": true,\n    \"z\": true,\n    \"poza\": true,\n    \"naszej\": true,\n    \"anonimowej\": true,\n    \"funkcji\\\"\": true\n  }), \"#include <algorithm>\\n#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nint policz_znak(string napis, char znak) {\\n    return count_if(napis.begin(), napis.end(),\\n    [](char c) {\\n        return c == ' ';\\n    });\\n}\\n\\nint main() {\\n    cout << policz_znak(\\\"The quick brown fox jumps over the lazy dog\\\", 'e') << '\\\\n';\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"8[5:10] file=\\\"counting3.cpp\\\" subtitle=\\\"W nawiasach kwadratowych podajemy listę zmiennych, z których chcemy korzystać\\\"\",\n    \"8[5:10]\": true,\n    \"file\": \"\\\"counting3.cpp\\\"\",\n    \"subtitle\": \"\\\"W\",\n    \"nawiasach\": true,\n    \"kwadratowych\": true,\n    \"podajemy\": true,\n    \"listę\": true,\n    \"zmiennych,\": true,\n    \"z\": true,\n    \"których\": true,\n    \"chcemy\": true,\n    \"korzystać\\\"\": true\n  }), \"#include <algorithm>\\n#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nint policz_znak(string napis, char znak) {\\n    return count_if(napis.begin(), napis.end(),\\n    [znak](char c) {\\n        return c == znak;\\n    });\\n}\\n\\nint main() {\\n    cout << policz_znak(\\\"The quick brown fox jumps over the lazy dog\\\", 'e') << '\\\\n';\\n}\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"7:18 file=\\\"input.cpp\\\" subtitle=\\\"Funkcje anonimowe przydadzą się też, gdy mamy pewien powtarzający się szkielet algorytmu\\\"\",\n    \"7:18\": true,\n    \"file\": \"\\\"input.cpp\\\"\",\n    \"subtitle\": \"\\\"Funkcje\",\n    \"anonimowe\": true,\n    \"przydadzą\": true,\n    \"się\": true,\n    \"też,\": true,\n    \"gdy\": true,\n    \"mamy\": true,\n    \"pewien\": true,\n    \"powtarzający\": true,\n    \"szkielet\": true,\n    \"algorytmu\\\"\": true\n  }), \"#include <algorithm>\\n#include <functional>\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nvoid wczytaj_liste(function<bool(int)> f) {\\n    cout << \\\"Liczba element\\xF3w? \\\";\\n    int n;\\n    cin >> n;\\n    while (n > 0) {\\n        int element;\\n        cin >> element;\\n        if (f(element)) {\\n            n--;\\n        }\\n    }\\n}\\n\\nint main() {\\n    cout << \\\"Podaj liczby pierwsze.\\\\n\\\";\\n    vector<int> pierwsze;\\n    int suma = 0;\\n    wczytaj_liste([&pierwsze, &suma](int p) {\\n        if (czy_pierwsza(p)) {\\n            pierwsze.push_back(p);\\n            suma += p;\\n            return true;\\n        } else {\\n            cout << p << \\\" nie jest pierwsza\\\\n\\\";\\n            return false;\\n        }\\n    });\\n\\n    sort(pierwsze.begin(), pierwsze.end());\\n    cout << \\\"Mediana: \\\" << pierwsze[pierwsze.size() / 2] << '\\\\n';\\n    cout << \\\"\\u015Arednia: \\\" << suma / (double)pierwsze.size() << '\\\\n';\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"7[20:38],2 subtitle=\\\"Funkcja ma typ function. Pamiętajmy o dołączeniu odpowiedniego pliku nagłówka.\\\"\",\n    \"7[20:38],2\": true,\n    \"subtitle\": \"\\\"Funkcja\",\n    \"ma\": true,\n    \"typ\": true,\n    \"function.\": true,\n    \"Pamiętajmy\": true,\n    \"o\": true,\n    \"dołączeniu\": true,\n    \"odpowiedniego\": true,\n    \"pliku\": true,\n    \"nagłówka.\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"7[29:32] subtitle=\\\"Przed nawiasami podajemy typ, jaki funkcja powinna zwracać\\\"\",\n    \"7[29:32]\": true,\n    \"subtitle\": \"\\\"Przed\",\n    \"nawiasami\": true,\n    \"podajemy\": true,\n    \"typ,\": true,\n    \"jaki\": true,\n    \"funkcja\": true,\n    \"powinna\": true,\n    \"zwracać\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"7[33:37] subtitle=\\\"A potem listę typów argumentów\\\"\",\n    \"7[33:37]\": true,\n    \"subtitle\": \"\\\"A\",\n    \"potem\": true,\n    \"listę\": true,\n    \"typów\": true,\n    \"argumentów\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"7[33:44] file=\\\"input-othersig.cpp\\\" subtitle=\\\"Gdy typów jest wiele, oddzielamy je przecinkami\\\"\",\n    \"7[33:44]\": true,\n    \"file\": \"\\\"input-othersig.cpp\\\"\",\n    \"subtitle\": \"\\\"Gdy\",\n    \"typów\": true,\n    \"jest\": true,\n    \"wiele,\": true,\n    \"oddzielamy\": true,\n    \"je\": true,\n    \"przecinkami\\\"\": true\n  }), \"#include <algorithm>\\n#include <functional>\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nvoid wczytaj_liste(function<void(int,double)> f) {\\n    cout << \\\"Liczba element\\xF3w? \\\";\\n    int n;\\n    cin >> n;\\n    while (n > 0) {\\n        int element;\\n        cin >> element;\\n        if (f(element)) {\\n            n--;\\n        }\\n    }\\n}\\n\\nint main() {\\n    cout << \\\"Podaj liczby pierwsze.\\\\n\\\";\\n    vector<int> pierwsze;\\n    int suma = 0;\\n    wczytaj_liste([&pierwsze, &suma](int p) {\\n        if (czy_pierwsza(p)) {\\n            pierwsze.push_back(p);\\n            suma += p;\\n            return true;\\n        } else {\\n            cout << p << \\\" nie jest pierwsza\\\\n\\\";\\n            return false;\\n        }\\n    });\\n\\n    sort(pierwsze.begin(), pierwsze.end());\\n    cout << \\\"Mediana: \\\" << pierwsze[pierwsze.size() / 2] << '\\\\n';\\n    cout << \\\"\\u015Arednia: \\\" << suma / (double)pierwsze.size() << '\\\\n';\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"7[29:32] subtitle=\\\"A gdy funkcja nic nie zwraca, podajemy void\\\"\",\n    \"7[29:32]\": true,\n    \"subtitle\": \"\\\"A\",\n    \"gdy\": true,\n    \"funkcja\": true,\n    \"nic\": true,\n    \"nie\": true,\n    \"zwraca,\": true,\n    \"podajemy\": true,\n    \"void\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"14[13:22] file=\\\"input.cpp\\\" subtitle=\\\"Funkcję którą przechowujemy w zmiennej wywołamy tak jak każdą inną\\\"\",\n    \"14[13:22]\": true,\n    \"file\": \"\\\"input.cpp\\\"\",\n    \"subtitle\": \"\\\"Funkcję\",\n    \"którą\": true,\n    \"przechowujemy\": true,\n    \"w\": true,\n    \"zmiennej\": true,\n    \"wywołamy\": true,\n    \"tak\": true,\n    \"jak\": true,\n    \"każdą\": true,\n    \"inną\\\"\": true\n  }), \"#include <algorithm>\\n#include <functional>\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nvoid wczytaj_liste(function<bool(int)> f) {\\n    cout << \\\"Liczba element\\xF3w? \\\";\\n    int n;\\n    cin >> n;\\n    while (n > 0) {\\n        int element;\\n        cin >> element;\\n        if (f(element)) {\\n            n--;\\n        }\\n    }\\n}\\n\\nint main() {\\n    cout << \\\"Podaj liczby pierwsze.\\\\n\\\";\\n    vector<int> pierwsze;\\n    int suma = 0;\\n    wczytaj_liste([&pierwsze, &suma](int p) {\\n        if (czy_pierwsza(p)) {\\n            pierwsze.push_back(p);\\n            suma += p;\\n            return true;\\n        } else {\\n            cout << p << \\\" nie jest pierwsza\\\\n\\\";\\n            return false;\\n        }\\n    });\\n\\n    sort(pierwsze.begin(), pierwsze.end());\\n    cout << \\\"Mediana: \\\" << pierwsze[pierwsze.size() / 2] << '\\\\n';\\n    cout << \\\"\\u015Arednia: \\\" << suma / (double)pierwsze.size() << '\\\\n';\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"24:33\",\n    \"24:33\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"24[20,31],26:27 subtitle=\\\"Domyślnie objekt funkcji anonimowej zawiera kopię zmiennej. By modyfikować zmienne do których się odnosimy, musimy użyć & by objekt funkcji przechowywał referencję do zmiennych\\\"\",\n    \"24[20,31],26:27\": true,\n    \"subtitle\": \"\\\"Domyślnie\",\n    \"objekt\": true,\n    \"funkcji\": true,\n    \"anonimowej\": true,\n    \"zawiera\": true,\n    \"kopię\": true,\n    \"zmiennej.\": true,\n    \"By\": true,\n    \"modyfikować\": true,\n    \"zmienne\": true,\n    \"do\": true,\n    \"których\": true,\n    \"się\": true,\n    \"odnosimy,\": true,\n    \"musimy\": true,\n    \"użyć\": true,\n    \"&\": true,\n    \"by\": true,\n    \"przechowywał\": true,\n    \"referencję\": true,\n    \"zmiennych\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"24[19:21] file=\\\"input-inferred.cpp\\\" subtitle=\\\"Możemy poprosić kompilator by sam znalazł zmienne, których używamy\\\"\",\n    \"24[19:21]\": true,\n    \"file\": \"\\\"input-inferred.cpp\\\"\",\n    \"subtitle\": \"\\\"Możemy\",\n    \"poprosić\": true,\n    \"kompilator\": true,\n    \"by\": true,\n    \"sam\": true,\n    \"znalazł\": true,\n    \"zmienne,\": true,\n    \"których\": true,\n    \"używamy\\\"\": true\n  }), \"#include <algorithm>\\n#include <functional>\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nvoid wczytaj_liste(function<bool(int)> f) {\\n    cout << \\\"Liczba element\\xF3w? \\\";\\n    int n;\\n    cin >> n;\\n    while (n > 0) {\\n        int element;\\n        cin >> element;\\n        if (f(element)) {\\n            n--;\\n        }\\n    }\\n}\\n\\nint main() {\\n    cout << \\\"Podaj liczby pierwsze.\\\\n\\\";\\n    vector<int> pierwsze;\\n    int suma = 0;\\n    wczytaj_liste([&](int p) {\\n        if (czy_pierwsza(p)) {\\n            pierwsze.push_back(p);\\n            suma += p;\\n            return true;\\n        } else {\\n            cout << p << \\\" nie jest pierwsza\\\\n\\\";\\n            return false;\\n        }\\n    });\\n\\n    sort(pierwsze.begin(), pierwsze.end());\\n    cout << \\\"Mediana: \\\" << pierwsze[pierwsze.size() / 2] << '\\\\n';\\n    cout << \\\"\\u015Arednia: \\\" << suma / (double)pierwsze.size() << '\\\\n';\\n}\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1[15:16],3,10,5[18:25],8[13:14] file=\\\"digit-input.cpp\\\" subtitle=\\\"Czasami najważniejsze jest to, że możemy wykorzystywać zmienne z poza funkcji anonimowej.\\\"\",\n    \"1[15:16],3,10,5[18:25],8[13:14]\": true,\n    \"file\": \"\\\"digit-input.cpp\\\"\",\n    \"subtitle\": \"\\\"Czasami\",\n    \"najważniejsze\": true,\n    \"jest\": true,\n    \"to,\": true,\n    \"że\": true,\n    \"możemy\": true,\n    \"wykorzystywać\": true,\n    \"zmienne\": true,\n    \"z\": true,\n    \"poza\": true,\n    \"funkcji\": true,\n    \"anonimowej.\\\"\": true\n  }), \"std::ifstream in(name);\\n\\nauto get_digit = [&]() {\\n    do {\\n        char c = in.get();\\n        if (c == '0') return 0;\\n        if (c == '1') return 1;\\n    } while(in);\\n    return -1;\\n};\\n\\nsize_t total = 0;\\nfor(;;) {\\n    uint8_t value = 0;\\n    for (int i = 0; i < 8; i++) {\\n        int digit = get_digit();\\n        if (digit == -1) return total;\\n        value <<= 1;\\n        value += digit;\\n    }\\n    if (value == 64) total++;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"6[23:31],7[23:31] subtitle=\\\"W tym przypadku chciałem wykorzystać polecenie return do zakończenia wykonywania części kodu.\\\"\",\n    \"6[23:31],7[23:31]\": true,\n    \"subtitle\": \"\\\"W\",\n    \"tym\": true,\n    \"przypadku\": true,\n    \"chciałem\": true,\n    \"wykorzystać\": true,\n    \"polecenie\": true,\n    \"return\": true,\n    \"do\": true,\n    \"zakończenia\": true,\n    \"wykonywania\": true,\n    \"części\": true,\n    \"kodu.\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"16[21:32] subtitle=\\\"Pozwala to również podzielić kod na logiczne operacje.\\\"\",\n    \"16[21:32]\": true,\n    \"subtitle\": \"\\\"Pozwala\",\n    \"to\": true,\n    \"również\": true,\n    \"podzielić\": true,\n    \"kod\": true,\n    \"na\": true,\n    \"logiczne\": true,\n    \"operacje.\\\"\": true\n  }), \"\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"3:5,10[39:53],11[9:25],12[32:47] file=\\\"fill-matrix.cpp\\\" subtitle=\\\"Funkcje przypisane do zmiennej przydają się również, kiedy daną rzecz musimy zrobić kilka razy, a musimy wykorzystać lokalne zmienne.\\\"\",\n    \"3:5,10[39:53],11[9:25],12[32:47]\": true,\n    \"file\": \"\\\"fill-matrix.cpp\\\"\",\n    \"subtitle\": \"\\\"Funkcje\",\n    \"przypisane\": true,\n    \"do\": true,\n    \"zmiennej\": true,\n    \"przydają\": true,\n    \"się\": true,\n    \"również,\": true,\n    \"kiedy\": true,\n    \"daną\": true,\n    \"rzecz\": true,\n    \"musimy\": true,\n    \"zrobić\": true,\n    \"kilka\": true,\n    \"razy,\": true,\n    \"a\": true,\n    \"wykorzystać\": true,\n    \"lokalne\": true,\n    \"zmienne.\\\"\": true\n  }), \"int * fill_matrix(size_t n) {\\n    int * M = new int[n * n];\\n    auto m = [&](size_t a, size_t b) -> int& {\\n        return M[a * n + b];\\n    };\\n\\n    for (size_t row = 0; row < n; row++) {\\n        size_t zero_pos = n - row - 1;\\n        size_t col = 0;\\n        for (; col < zero_pos; col++) m(row, col) = 1;\\n        m(row, col++) = 0;\\n        for (; col < n; col++) m(row, col) = -1;\\n    }\\n\\n    return M;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"3[44],10[39:53],11[9:25],12[32:47] subtitle=\\\"W tym przypadku funkcja zwraca referencję, więc do zwróconej zmiennej mogę przypisać wartość.\\\"\",\n    \"3[44],10[39:53],11[9:25],12[32:47]\": true,\n    \"subtitle\": \"\\\"W\",\n    \"tym\": true,\n    \"przypadku\": true,\n    \"funkcja\": true,\n    \"zwraca\": true,\n    \"referencję,\": true,\n    \"więc\": true,\n    \"do\": true,\n    \"zwróconej\": true,\n    \"zmiennej\": true,\n    \"mogę\": true,\n    \"przypisać\": true,\n    \"wartość.\\\"\": true\n  }), \"\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"subtitle=\\\"Przykład z większego projektu: funkcje anonimowe wykorzystane do określenia kodu, który ma się wykonać gdy użytkownik wciśnie przycisk.\\\"\",\n    \"subtitle\": \"\\\"Przykład\",\n    \"z\": true,\n    \"większego\": true,\n    \"projektu:\": true,\n    \"funkcje\": true,\n    \"anonimowe\": true,\n    \"wykorzystane\": true,\n    \"do\": true,\n    \"określenia\": true,\n    \"kodu,\": true,\n    \"który\": true,\n    \"ma\": true,\n    \"się\": true,\n    \"wykonać\": true,\n    \"gdy\": true,\n    \"użytkownik\": true,\n    \"wciśnie\": true,\n    \"przycisk.\\\"\": true\n  }), \"incrementStateSlot.onPress = [&] {\\n    if(stateSlot < 5) stateSlot++;\\n    else stateSlot = 1;\\n};\\nhotkeys.append(&incrementStateSlot);\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"1[30:32] subtitle=\\\"Gdy funkcję przechowujemy w zmiennej, musimy upewnić się, że zmienne schwytane przez referencję dalej istnieją w momencie gdy funkcja zostaje wywołana.\\\"\",\n    \"1[30:32]\": true,\n    \"subtitle\": \"\\\"Gdy\",\n    \"funkcję\": true,\n    \"przechowujemy\": true,\n    \"w\": true,\n    \"zmiennej,\": true,\n    \"musimy\": true,\n    \"upewnić\": true,\n    \"się,\": true,\n    \"że\": true,\n    \"zmienne\": true,\n    \"schwytane\": true,\n    \"przez\": true,\n    \"referencję\": true,\n    \"dalej\": true,\n    \"istnieją\": true,\n    \"momencie\": true,\n    \"gdy\": true,\n    \"funkcja\": true,\n    \"zostaje\": true,\n    \"wywołana.\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1[20:26],2[40:45] subtitle=\\\"W tym przypadku przydaje się wariant składni, który kopiuje zmienne\\\"\",\n    \"1[20:26],2[40:45]\": true,\n    \"subtitle\": \"\\\"W\",\n    \"tym\": true,\n    \"przypadku\": true,\n    \"przydaje\": true,\n    \"się\": true,\n    \"wariant\": true,\n    \"składni,\": true,\n    \"który\": true,\n    \"kopiuje\": true,\n    \"zmienne\\\"\": true\n  }), \"auto gammaAdjust = [gamma](double f) {\\n    return f < 0.0 ? 0.0 : pow(f, 2.2 / gamma);\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1[20:22] subtitle=\\\"(dostępne również w wariancie automatycznym)\\\"\",\n    \"1[20:22]\": true,\n    \"subtitle\": \"\\\"(dostępne\",\n    \"również\": true,\n    \"w\": true,\n    \"wariancie\": true,\n    \"automatycznym)\\\"\": true\n  }), \"auto gammaAdjust = [=](double f) {\\n    return f < 0.0 ? 0.0 : pow(f, 2.2 / gamma);\\n};\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"2,12 subtitle=\\\"Telegram wykorzystuje funkcje anonimowe by zaplanować kod, który ma być wykonany później\\\"\",\n    \"2,12\": true,\n    \"subtitle\": \"\\\"Telegram\",\n    \"wykorzystuje\": true,\n    \"funkcje\": true,\n    \"anonimowe\": true,\n    \"by\": true,\n    \"zaplanować\": true,\n    \"kod,\": true,\n    \"który\": true,\n    \"ma\": true,\n    \"być\": true,\n    \"wykonany\": true,\n    \"później\\\"\": true\n  }), \"void ConnectionsManager::bindRequestToGuid(int32_t requestToken, int32_t guid) {\\n    scheduleTask([&, requestToken, guid] {\\n        std::map<int32_t, std::vector<int32_t>>::iterator iter = requestsByGuids.find(guid);\\n        if (iter != requestsByGuids.end()) {\\n            iter->second.push_back(requestToken);\\n        } else {\\n            std::vector<int32_t> array;\\n            array.push_back(requestToken);\\n            requestsByGuids[guid] = array;\\n        }\\n        guidsByRequests[requestToken] = guid;\\n    });\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"1[6:23],2[19],3[66:80],4[21:35],11[9:23],9[13:27] subtitle=\\\"Za pomocą referencji używamy większości zmiennych, ponieważ znajdują się one w obiekcie ConnectionsManager który będzie istniał gdy funkcja zostanie wywołana.\\\"\",\n    \"1[6:23],2[19],3[66:80],4[21:35],11[9:23],9[13:27]\": true,\n    \"subtitle\": \"\\\"Za\",\n    \"pomocą\": true,\n    \"referencji\": true,\n    \"używamy\": true,\n    \"większości\": true,\n    \"zmiennych,\": true,\n    \"ponieważ\": true,\n    \"znajdują\": true,\n    \"się\": true,\n    \"one\": true,\n    \"w\": true,\n    \"obiekcie\": true,\n    \"ConnectionsManager\": true,\n    \"który\": true,\n    \"będzie\": true,\n    \"istniał\": true,\n    \"gdy\": true,\n    \"funkcja\": true,\n    \"zostanie\": true,\n    \"wywołana.\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"1[43:78],2[22:39],5[36:47],8[29:40],11[25:36,41:44],3[87:90],9[29:33] subtitle=\\\"Lecz argumenty funkcji nie będą istnieć, więc musimy je skopiować\\\"\",\n    \"1[43:78],2[22:39],5[36:47],8[29:40],11[25:36,41:44],3[87:90],9[29:33]\": true,\n    \"subtitle\": \"\\\"Lecz\",\n    \"argumenty\": true,\n    \"funkcji\": true,\n    \"nie\": true,\n    \"będą\": true,\n    \"istnieć,\": true,\n    \"więc\": true,\n    \"musimy\": true,\n    \"je\": true,\n    \"skopiować\\\"\": true\n  }), \"\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"subtitle=\\\"W jednej z bibliotek Microsoftu mamy funkcję, która wykona odpowiednik pętli for na wielu rdzeniach procesora na raz\\\"\",\n    \"subtitle\": \"\\\"W\",\n    \"jednej\": true,\n    \"z\": true,\n    \"bibliotek\": true,\n    \"Microsoftu\": true,\n    \"mamy\": true,\n    \"funkcję,\": true,\n    \"która\": true,\n    \"wykona\": true,\n    \"odpowiednik\": true,\n    \"pętli\": true,\n    \"for\": true,\n    \"na\": true,\n    \"wielu\": true,\n    \"rdzeniach\": true,\n    \"procesora\": true,\n    \"raz\\\"\": true\n  }), \"void ThreadPool::SimpleParallelFor(int total, const function<void(int)>& fn) {\\n  Barrier barrier(total);\\n  auto handle_iteration = [&barrier, &fn](int iteration) {\\n    fn(iteration);\\n    barrier.Notify();\\n  };\\n\\n  for (int id = 0; id < total; id++) {\\n    Schedule([=, &handle_iteration]() { handle_iteration(id); });\\n  }\\n\\n  barrier.Wait();\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"9,1[6:15] subtitle=\\\"Najtrudniejszą część wykonuje funkcja Schedule, która wykona przekazaną funkcję gdy któryś z rdzeni będzie miał wolną chwilę\\\"\",\n    \"9,1[6:15]\": true,\n    \"subtitle\": \"\\\"Najtrudniejszą\",\n    \"część\": true,\n    \"wykonuje\": true,\n    \"funkcja\": true,\n    \"Schedule,\": true,\n    \"która\": true,\n    \"wykona\": true,\n    \"przekazaną\": true,\n    \"funkcję\": true,\n    \"gdy\": true,\n    \"któryś\": true,\n    \"z\": true,\n    \"rdzeni\": true,\n    \"będzie\": true,\n    \"miał\": true,\n    \"wolną\": true,\n    \"chwilę\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"8[32:35],9[15,58:59] subtitle=\\\"Zmienna id jest kopiowana, ponieważ gdy zaplanowane zadanie zostanie wykonane, zmienna będzie miała inną wartość.\\\"\",\n    \"8[32:35],9[15,58:59]\": true,\n    \"subtitle\": \"\\\"Zmienna\",\n    \"id\": true,\n    \"jest\": true,\n    \"kopiowana,\": true,\n    \"ponieważ\": true,\n    \"gdy\": true,\n    \"zaplanowane\": true,\n    \"zadanie\": true,\n    \"zostanie\": true,\n    \"wykonane,\": true,\n    \"zmienna\": true,\n    \"będzie\": true,\n    \"miała\": true,\n    \"inną\": true,\n    \"wartość.\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"3[3:25],9[18:34,41:56] subtitle=\\\"Zmiennej handle_iteration nie kopiujemy, ponieważ będzie istnieć cały czas w nie zmienionej postaci\\\"\",\n    \"3[3:25],9[18:34,41:56]\": true,\n    \"subtitle\": \"\\\"Zmiennej\",\n    \"handle_iteration\": true,\n    \"nie\": true,\n    \"kopiujemy,\": true,\n    \"ponieważ\": true,\n    \"będzie\": true,\n    \"istnieć\": true,\n    \"cały\": true,\n    \"czas\": true,\n    \"w\": true,\n    \"zmienionej\": true,\n    \"postaci\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"2,5,12 subtitle=\\\"Zapewnia to bariera\\\"\",\n    \"2,5,12\": true,\n    \"subtitle\": \"\\\"Zapewnia\",\n    \"to\": true,\n    \"bariera\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"1[36:44],2[19:23],8[25:29] subtitle=\\\"Gdy jest tworzona, zapisujemy ilu powiadomień oczekujemy\\\"\",\n    \"1[36:44],2[19:23],8[25:29]\": true,\n    \"subtitle\": \"\\\"Gdy\",\n    \"jest\": true,\n    \"tworzona,\": true,\n    \"zapisujemy\": true,\n    \"ilu\": true,\n    \"powiadomień\": true,\n    \"oczekujemy\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"5\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"5 subtitle=\\\"Za każdym razem, gdy jedna z równocześnie wykonywanych iteracji pętli się wykona, wysyłamy jedno z nich\\\"\",\n    \"subtitle\": \"\\\"Za\",\n    \"każdym\": true,\n    \"razem,\": true,\n    \"gdy\": true,\n    \"jedna\": true,\n    \"z\": true,\n    \"równocześnie\": true,\n    \"wykonywanych\": true,\n    \"iteracji\": true,\n    \"pętli\": true,\n    \"się\": true,\n    \"wykona,\": true,\n    \"wysyłamy\": true,\n    \"jedno\": true,\n    \"nich\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"12\": true,\n    \"className\": \"language-diff\",\n    \"metastring\": \"12 subtitle=\\\"Przed wyjściem z funkcji czekamy, aż wszystkie zostaną wysłane\\\"\",\n    \"subtitle\": \"\\\"Przed\",\n    \"wyjściem\": true,\n    \"z\": true,\n    \"funkcji\": true,\n    \"czekamy,\": true,\n    \"aż\": true,\n    \"wszystkie\": true,\n    \"zostaną\": true,\n    \"wysłane\\\"\": true\n  }), \"\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\",\n    \"metastring\": \"1[14:35],2[14:36],3[14:20] subtitle=\\\"W tym przypadku listę zmiennych możemy zapisać na kilka równoważnych sposobów. Pozostaje ocenić, który jest najbardziej oczywisty.\\\"\",\n    \"1[14:35],2[14:36],3[14:20]\": true,\n    \"subtitle\": \"\\\"W\",\n    \"tym\": true,\n    \"przypadku\": true,\n    \"listę\": true,\n    \"zmiennych\": true,\n    \"możemy\": true,\n    \"zapisać\": true,\n    \"na\": true,\n    \"kilka\": true,\n    \"równoważnych\": true,\n    \"sposobów.\": true,\n    \"Pozostaje\": true,\n    \"ocenić,\": true,\n    \"który\": true,\n    \"jest\": true,\n    \"najbardziej\": true,\n    \"oczywisty.\\\"\": true\n  }), \"    Schedule([=, &handle_iteration]() { handle_iteration(id); });\\n    Schedule([id, &handle_iteration]() { handle_iteration(id); });\\n    Schedule([&, id]() { handle_iteration(id); });\\n\"))), mdx(\"hr\", null), mdx(\"h1\", null, \"Pytania?\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://niedzejkob.github.io/cpplambdas\"\n  }), \"https://niedzejkob.github.io/cpplambdas\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"matchPath":"/*","id":"94bb3911-39bb-5b62-992b-af73127caa8b","slug":"/cpplambdas","title":"Wyrażenia lambda"}}}